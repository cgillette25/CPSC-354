\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref} % For clickable links in the Table of Contents
\usepackage{amsthm}


\title{CPSC-354 Report}
\author{Chaz Gillette}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage


\section{Week 1: Introduction to Lean and Natural Number Game Tutorial}
\label{sec:week1}

In week one, we worked with Lean and reviewed our discrete math knowledge in the Number Game Tutorial. Problems and solutions are listed below.

\subsection*{Homework Solutions: Week 1}

\subsubsection*{Level 5}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 6}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero c]}

\texttt{rw [add\_zero b]}

\texttt{rfl}

\subsubsection*{Level 7: succ\_eq\_add\_one Theorem}
\texttt{Theorem succ\_eq\_add\_one: For all natural numbers a, we have succ(a) = a + 1}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 8: 2 + 2 = 4}
\texttt{2 + 2 = 4.}

\texttt{nth\_rewrite 2 [two\_eq\_succ\_one] -- only change the second `2` to `succ 1`.}

\texttt{rw [add\_succ]}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ, add\_zero] -- two rewrites at once}

\texttt{rw [\textbackslash three\_eq\_succ\_two] -- change `succ 2` to `3`}

\texttt{rw [\textbackslash four\_eq\_succ\_three]}

\texttt{rfl}

\subsection*{Detailed Explanation: Level 7 Proof}
I chose to explain the proof for level seven because this is where we make the breakthrough with addition. Our goal is to prove that the successor of \(a\) is equal to \(a + 1\). So, in step one, we want to rewrite one as the successor of zero. That gives us \(\text{succ } n = n + \text{succ } 0\). The next step is `add\_succ` so that \(\text{succ } n = \text{succ } (n + 0)\). After that, we can remove the zero by `rw [add\_zero]`, which will leave us with \(\text{succ } n = \text{succ } n\), which is thus proven true with the reflexive property.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 1}
Week one was our review and introduction to the math side of what we'll be learning this semester. We started by revisiting the basic rules of discrete math. This meant getting back into the flow of writing out our proofs using the rules that we have access to. With only natural numbers to start, we started looking at successors again and eventually proving our way toward addition.

For me, this was a needed refresher because it's been a moment since I took discrete math, and I'm unfamiliar with writing my proofs as code, which is a learning curve for me. I'm a very pen-to-paper mathematician, so thinking about math at the same time I'm trying to recall syntax for code is a challenge for me. That said, we went through eight levels of proofs, and I was able to begin to get the hang of it.

I'm looking forward to bridging the gap between my math knowledge and how I involve it when I code. Sometimes I feel like I have the education to understand the concepts, but I struggle to apply them when I'm coding. The speed in which I type out code is not as quick as how I think about what I'd like to apply. This first assignment was a nice intro to opening my eyes as to what it might look like to get faster at that and also write technical reports in a coding environment as well. By shifting everything I do—the code, the math, the reporting—into an IDE, I know that I'll be able to get more comfortable working in that environment.

\section{Week 2: Finishing the NNG Addition World}
\label{sec:week2}

In week two, we focused on completing the Natural Number Game (NNG) Addition World, which helped solidify our understanding of addition in Lean. The problems and solutions for Levels 1-5 are listed below.

\subsection*{Homework Solutions: Week 2}

\subsubsection*{Level 1: zero\_add}
\texttt{theorem zero\_add (n : nat) : 0 + n = n := by}

\texttt{induction n with d hd}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rfl}

\subsubsection*{Level 2: succ\_add}
\texttt{theorem succ\_add (a b : nat) : succ a + b = succ (a + b) := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_succ]}

\texttt{rfl}

\subsubsection*{Level 3: add\_comm}
\texttt{theorem add\_comm (a b : nat) : a + b = b + a := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [zero\_add]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsubsection*{Level 4: add\_assoc}
\texttt{theorem add\_assoc (a b c : nat) : a + b + c = a + (b + c) := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rfl}

\subsubsection*{Level 5: add\_right\_comm}

\texttt{theorem add\_right\_comm (a b c : nat) : a + b + c = a + c + b := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsection*{Mathematical Proof for Level 5: add\_right\_comm}
The goal is to prove the right commutativity of addition, meaning for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is done by using induction on \(c\).

\textbf{Base Case:} When \(c = 0\), we need to prove:
\[
a + b + 0 = a + 0 + b
\]
Using the identity property of addition, we know that \(a + 0 = a\) and \(0 + b = b\). Thus, both sides simplify to:
\[
a + b = a + b
\]
which is clearly true.

\textbf{Inductive Step:} Assume that the right commutativity holds for some \(c\), i.e.:
\[
a + b + c = a + c + b
\]
Now, we must show that the commutativity holds for \(\text{succ}(c)\), i.e., that:
\[
a + b + \text{succ}(c) = a + \text{succ}(c) + b
\]
By the definition of the successor function and the properties of addition, we can rewrite the left-hand side:
\[
a + b + \text{succ}(c) = \text{succ}(a + b + c)
\]
By the inductive hypothesis, we know that \(a + b + c = a + c + b\), so we substitute this in:
\[
\text{succ}(a + c + b) = a + \text{succ}(c) + b
\]
which completes the inductive step. Therefore, by the principle of induction, we conclude that for all natural numbers \(a\), \(b\), and \(c\):
\[
a + b + c = a + c + b
\]
\qed

\subsection*{Detailed Explanation: Level 5 Proof (add\_right\_comm)}
In this proof the goal is to show that for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is commutativity of addition. I attempted the proof by induction on \(c\).

1. Base case: When \(c = 0\), the goal is to prove \(a + b + 0 = a + 0 + b\). Using the definition of addition, \(a + 0 = a\), so both sides reduce to \(a + b\). Then we rewrite tactic `rw [add\_zero]` and `rfl` confirms it.
  
2. Inductive step: We assume that \(a + b + c = a + c + b\) holds for some \(c\), and we must prove \(a + b + \text{succ}(c) = a + \text{succ}(c) + b\). First we rewrite the addition of the successor using the `add\_succ` rule. Then by applying the inductive hypothesis and the commutativity of addition, we can transform both sides to eventually match, proving the equality.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 2}
In week two we dived into the realtionship between mathematical proofs and lean proofs. We saw that the code in an of itself is a proof and in each step we are just translating into a language the lean will understand. Additionally, we spent time looking at how to prove things recursively. Looking at functions that call themselves as a solution. This requires a base case with a simple solution, like moving a single ring to the right tower, and the replace that simple solution with n so that we can continue to reduce down to our basecase and solve for any number of rings up to infinity. This is what we do in our unductive proofs, we have our base case, then our hypothesis for n + 1 and prove for all cases. 

\section{Week 3: Using LLMs for Literature Review}
\label{sec:week3}


In Week 3, I explored the topic of \textbf{Quantum Programming Languages} using an LLM to guide my investigation. I also began to code a computer in python without the help of any libraries.

\subsection*{Link to the Full Literature Review}
The full literature review, including the questions and answers from the LLM, can be found \href{https://github.com/cgillette25/CPSC-354/blob/main/week3/README.md}{here}.

\subsection*{Discord Post}

My discord name is Chaz Gillette and below is a copy of my Discord post summarizing the literature review:

\begin{quote}
For my literature review, I explored the development of quantum programming languages and their relevance in modern computing. Beginning with early theoretical work by David Deutsch on the quantum Turing machine, I traced the evolution through landmark algorithms like Shor’s and Grover’s. These breakthroughs highlighted the practical need for specialized quantum programming languages capable of expressing quantum phenomena such as superposition, entanglement, and measurement.

The investigation revealed that subfields like formal language theory, type systems, and quantum information theory contributed to shaping quantum programming. For example, formal language theory provided the syntax for expressing quantum circuits, while type systems introduced linear types to track qubit usage.

Influential researchers such as Peter Shor, Michael A. Nielsen, and Peter Selinger have left their mark, with Selinger notably developing the Quipper language. Modern tools like Qiskit (IBM), Cirq (Google), and Q\# (Microsoft) are now widely used in both academia and industry.

In conclusion, quantum programming languages are a product of multiple converging fields, and their development is key to unlocking the full potential of quantum computing. My full investigation and references can be found in my \href{https://github.com/cgillette25/CPSC-354/blob/main/week3/README.md}{GitHub README}.
\end{quote}

\subsection*{Reviews I Voted For}
I voted for the following two reviews after reading them:

\begin{enumerate}
    \item \href{https://github.com/mdrivas/CPSC353-Assignment3/blob/main/README.md}{Review 1}
    \item \href{https://github.com/ATacoDev/LitReview354}{Review 2}
\end{enumerate}

\subsection*{Lessons Learned}
In week 3 I learned a lot about what makes programming for quantum computing different; mostly this is to do with the less binary nature of quantum computing compared to current computers. Outside of my report I learned how to break down order of operations when coding. Using functions to call other funcitons within parenthesis and begin to tackle the math equations like a real calculator would. 


\section*{Conclusion}
In week one, we reviewed our discrete math knowledge and began coding proofs. Week two we saw the relationship between mathematical proofs and lean code proofs, and then we began to solve problems recursively. The following week I took a dive into quantum computing languages in my literature review while also working on coding a calculator using a recursive approach to solve parenthesis. 

\end{document}
