\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref} % For clickable links in the Table of Contents
\usepackage{amsthm}


\title{CPSC-354 Report}
\author{Chaz Gillette}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\section*{Week 1: Introduction to Lean and Natural Number Game Tutorial}
In week one, we worked with Lean and reviewed our discrete math knowledge in the Number Game Tutorial. Problems and solutions are listed below.

\subsection*{Homework Solutions: Week 1}

\subsubsection*{Level 5}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 6}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero c]}

\texttt{rw [add\_zero b]}

\texttt{rfl}

\subsubsection*{Level 7: succ\_eq\_add\_one Theorem}
\texttt{Theorem succ\_eq\_add\_one: For all natural numbers a, we have succ(a) = a + 1}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 8: 2 + 2 = 4}
\texttt{2 + 2 = 4.}

\texttt{nth\_rewrite 2 [two\_eq\_succ\_one] -- only change the second `2` to `succ 1`.}

\texttt{rw [add\_succ]}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ, add\_zero] -- two rewrites at once}

\texttt{rw [\textbackslash three\_eq\_succ\_two] -- change `succ 2` to `3`}

\texttt{rw [\textbackslash four\_eq\_succ\_three]}

\texttt{rfl}

\subsection*{Detailed Explanation: Level 7 Proof}
I chose to explain the proof for level seven because this is where we make the breakthrough with addition. Our goal is to prove that the successor of \(a\) is equal to \(a + 1\). So, in step one, we want to rewrite one as the successor of zero. That gives us \(\text{succ } n = n + \text{succ } 0\). The next step is `add\_succ` so that \(\text{succ } n = \text{succ } (n + 0)\). After that, we can remove the zero by `rw [add\_zero]`, which will leave us with \(\text{succ } n = \text{succ } n\), which is thus proven true with the reflexive property.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 1}
Week one was our review and introduction to the math side of what we'll be learning this semester. We started by revisiting the basic rules of discrete math. This meant getting back into the flow of writing out our proofs using the rules that we have access to. With only natural numbers to start, we started looking at successors again and eventually proving our way toward addition.

For me, this was a needed refresher because it's been a moment since I took discrete math, and I'm unfamiliar with writing my proofs as code, which is a learning curve for me. I'm a very pen-to-paper mathematician, so thinking about math at the same time I'm trying to recall syntax for code is a challenge for me. That said, we went through eight levels of proofs, and I was able to begin to get the hang of it.

I'm looking forward to bridging the gap between my math knowledge and how I involve it when I code. Sometimes I feel like I have the education to understand the concepts, but I struggle to apply them when I'm coding. The speed in which I type out code is not as quick as how I think about what I'd like to apply. This first assignment was a nice intro to opening my eyes as to what it might look like to get faster at that and also write technical reports in a coding environment as well. By shifting everything I do—the code, the math, the reporting—into an IDE, I know that I'll be able to get more comfortable working in that environment.

\section*{Week 2: Finishing the NNG Addition World}
In week two, we focused on completing the Natural Number Game (NNG) Addition World, which helped solidify our understanding of addition in Lean. The problems and solutions for Levels 1-5 are listed below.

\subsection*{Homework Solutions: Week 2}

\subsubsection*{Level 1: zero\_add}
\texttt{theorem zero\_add (n : nat) : 0 + n = n := by}

\texttt{induction n with d hd}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rfl}

\subsubsection*{Level 2: succ\_add}
\texttt{theorem succ\_add (a b : nat) : succ a + b = succ (a + b) := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_succ]}

\texttt{rfl}

\subsubsection*{Level 3: add\_comm}
\texttt{theorem add\_comm (a b : nat) : a + b = b + a := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [zero\_add]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsubsection*{Level 4: add\_assoc}
\texttt{theorem add\_assoc (a b c : nat) : a + b + c = a + (b + c) := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rfl}

\subsubsection*{Level 5: add\_right\_comm}

\texttt{theorem add\_right\_comm (a b c : nat) : a + b + c = a + c + b := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsection*{Mathematical Proof for Level 5: add\_right\_comm}
The goal is to prove the right commutativity of addition, meaning for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is done by using induction on \(c\).

\textbf{Base Case:} When \(c = 0\), we need to prove:
\[
a + b + 0 = a + 0 + b
\]
Using the identity property of addition, we know that \(a + 0 = a\) and \(0 + b = b\). Thus, both sides simplify to:
\[
a + b = a + b
\]
which is clearly true.

\textbf{Inductive Step:} Assume that the right commutativity holds for some \(c\), i.e.:
\[
a + b + c = a + c + b
\]
Now, we must show that the commutativity holds for \(\text{succ}(c)\), i.e., that:
\[
a + b + \text{succ}(c) = a + \text{succ}(c) + b
\]
By the definition of the successor function and the properties of addition, we can rewrite the left-hand side:
\[
a + b + \text{succ}(c) = \text{succ}(a + b + c)
\]
By the inductive hypothesis, we know that \(a + b + c = a + c + b\), so we substitute this in:
\[
\text{succ}(a + c + b) = a + \text{succ}(c) + b
\]
which completes the inductive step. Therefore, by the principle of induction, we conclude that for all natural numbers \(a\), \(b\), and \(c\):
\[
a + b + c = a + c + b
\]
\qed

\subsection*{Detailed Explanation: Level 5 Proof (add\_right\_comm)}
In this proof the goal is to show that for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is commutativity of addition. I attempted the proof by induction on \(c\).

1. Base case: When \(c = 0\), the goal is to prove \(a + b + 0 = a + 0 + b\). Using the definition of addition, \(a + 0 = a\), so both sides reduce to \(a + b\). Then we rewrite tactic `rw [add\_zero]` and `rfl` confirms it.
  
2. Inductive step: We assume that \(a + b + c = a + c + b\) holds for some \(c\), and we must prove \(a + b + \text{succ}(c) = a + \text{succ}(c) + b\). First we rewrite the addition of the successor using the `add\_succ` rule. Then by applying the inductive hypothesis and the commutativity of addition, we can transform both sides to eventually match, proving the equality.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 2}
In week two we dived into the realtionship between mathematical proofs and lean proofs. We saw that the code in an of itself is a proof and in each step we are just translating into a language the lean will understand. Additionally, we spent time looking at how to prove things recursively. Looking at functions that call themselves as a solution. This requires a base case with a simple solution, like moving a single ring to the right tower, and the replace that simple solution with n so that we can continue to reduce down to our basecase and solve for any number of rings up to infinity. This is what we do in our unductive proofs, we have our base case, then our hypothesis for n + 1 and prove for all cases. 
\section*{Conclusion}
In week one, we reviewed our discrete math knowledge and began coding proofs. Week two we saw the relationship between mathematical proofs and lean code proofs, and then we began to solve problems recursively. 

\end{document}
