\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref} % For clickable links in the Table of Contents
\usepackage{amsthm}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{listings}
% Removed fontspec and setmonofont as they're typically used with XeLaTeX or LuaLaTeX

\usepackage{xcolor}

% Combined Lean Style Definition
\lstdefinestyle{leanstyle}{
    language=Python, % Using Python as a base for syntax highlighting
    basicstyle=\ttfamily\small,
    keywordstyle=\bfseries\color{blue},
    commentstyle=\itshape\color{gray},
    stringstyle=\color{orange},
    mathescape=true, % Allows math symbols in the listing
    escapeinside={(*@}{@*)}, % Custom escape characters for LaTeX
    literate={⟨}{{$\langle$}}1 {⟩}{{$\rangle$}}1 {∧}{{$\land$}}1 {\\/}{{$\lor$}}1 {¬}{{$\lnot$}}1,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    keepspaces=true,
    columns=flexible,
}

\title{CPSC-354 Report}
\author{Chaz Gillette}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage


\section{Week 1: Introduction to Lean and Natural Number Game Tutorial}
\label{sec:week1}

In week one, we worked with Lean and reviewed our discrete math knowledge in the Number Game Tutorial. Problems and solutions are listed below.

\subsection*{Homework Solutions: Week 1}

\subsubsection*{Level 5}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 6}
\texttt{a + (b + 0) + (c + 0) = a + b + c.}

\texttt{rw [add\_zero c]}

\texttt{rw [add\_zero b]}

\texttt{rfl}

\subsubsection*{Level 7: succ\_eq\_add\_one Theorem}
\texttt{Theorem succ\_eq\_add\_one: For all natural numbers a, we have succ(a) = a + 1}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\subsubsection*{Level 8: 2 + 2 = 4}
\texttt{2 + 2 = 4.}

\texttt{nth\_rewrite 2 [two\_eq\_succ\_one] -- only change the second `2` to `succ 1`.}

\texttt{rw [add\_succ]}

\texttt{rw [one\_eq\_succ\_zero]}

\texttt{rw [add\_succ, add\_zero] -- two rewrites at once}

\texttt{rw [\textbackslash three\_eq\_succ\_two] -- change `succ 2` to `3`}

\texttt{rw [\textbackslash four\_eq\_succ\_three]}

\texttt{rfl}

\subsection*{Detailed Explanation: Level 7 Proof}
I chose to explain the proof for level seven because this is where we make the breakthrough with addition. Our goal is to prove that the successor of \(a\) is equal to \(a + 1\). So, in step one, we want to rewrite one as the successor of zero. That gives us \(\text{succ } n = n + \text{succ } 0\). The next step is `add\_succ` so that \(\text{succ } n = \text{succ } (n + 0)\). After that, we can remove the zero by `rw [add\_zero]`, which will leave us with \(\text{succ } n = \text{succ } n\), which is thus proven true with the reflexive property.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 1}
Week one was our review and introduction to the math side of what we'll be learning this semester. We started by revisiting the basic rules of discrete math. This meant getting back into the flow of writing out our proofs using the rules that we have access to. With only natural numbers to start, we started looking at successors again and eventually proving our way toward addition.

For me, this was a needed refresher because it's been a moment since I took discrete math, and I'm unfamiliar with writing my proofs as code, which is a learning curve for me. I'm a very pen-to-paper mathematician, so thinking about math at the same time I'm trying to recall syntax for code is a challenge for me. That said, we went through eight levels of proofs, and I was able to begin to get the hang of it.

I'm looking forward to bridging the gap between my math knowledge and how I involve it when I code. Sometimes I feel like I have the education to understand the concepts, but I struggle to apply them when I'm coding. The speed in which I type out code is not as quick as how I think about what I'd like to apply. This first assignment was a nice intro to opening my eyes as to what it might look like to get faster at that and also write technical reports in a coding environment as well. By shifting everything I do—the code, the math, the reporting—into an IDE, I know that I'll be able to get more comfortable working in that environment.

\section{Week 2: Finishing the NNG Addition World}
\label{sec:week2}

In week two, we focused on completing the Natural Number Game (NNG) Addition World, which helped solidify our understanding of addition in Lean. The problems and solutions for Levels 1-5 are listed below.

\subsection*{Homework Solutions: Week 2}

\subsubsection*{Level 1: zero\_add}
\texttt{theorem zero\_add (n : nat) : 0 + n = n := by}

\texttt{induction n with d hd}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rfl}

\subsubsection*{Level 2: succ\_add}
\texttt{theorem succ\_add (a b : nat) : succ a + b = succ (a + b) := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_succ]}

\texttt{rfl}

\subsubsection*{Level 3: add\_comm}
\texttt{theorem add\_comm (a b : nat) : a + b = b + a := by}

\texttt{induction b with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [zero\_add]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsubsection*{Level 4: add\_assoc}
\texttt{theorem add\_assoc (a b c : nat) : a + b + c = a + (b + c) := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rfl}

\subsubsection*{Level 5: add\_right\_comm}

\texttt{theorem add\_right\_comm (a b c : nat) : a + b + c = a + c + b := by}

\texttt{induction c with d hd}

\texttt{rw [add\_zero]}

\texttt{rw [add\_zero]}

\texttt{rfl}

\texttt{rw [add\_succ]}

\texttt{rw [hd]}

\texttt{rw [add\_comm]}

\texttt{rw [add\_succ]}

\texttt{rw [add\_comm]}

\texttt{rw [succ\_add]}

\texttt{rfl}

\subsection*{Mathematical Proof for Level 5: add\_right\_comm}
The goal is to prove the right commutativity of addition, meaning for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is done by using induction on \(c\).

\textbf{Base Case:} When \(c = 0\), we need to prove:
\[
a + b + 0 = a + 0 + b
\]
Using the identity property of addition, we know that \(a + 0 = a\) and \(0 + b = b\). Thus, both sides simplify to:
\[
a + b = a + b
\]
which is clearly true.

\textbf{Inductive Step:} Assume that the right commutativity holds for some \(c\), i.e.:
\[
a + b + c = a + c + b
\]
Now, we must show that the commutativity holds for \(\text{succ}(c)\), i.e., that:
\[
a + b + \text{succ}(c) = a + \text{succ}(c) + b
\]
By the definition of the successor function and the properties of addition, we can rewrite the left-hand side:
\[
a + b + \text{succ}(c) = \text{succ}(a + b + c)
\]
By the inductive hypothesis, we know that \(a + b + c = a + c + b\), so we substitute this in:
\[
\text{succ}(a + c + b) = a + \text{succ}(c) + b
\]
which completes the inductive step. Therefore, by the principle of induction, we conclude that for all natural numbers \(a\), \(b\), and \(c\):
\[
a + b + c = a + c + b
\]
\qed

\subsection*{Detailed Explanation: Level 5 Proof (add\_right\_comm)}
In this proof the goal is to show that for all natural numbers \(a\), \(b\), and \(c\), the equation \(a + b + c = a + c + b\) holds. This is commutativity of addition. I attempted the proof by induction on \(c\).

1. Base case: When \(c = 0\), the goal is to prove \(a + b + 0 = a + 0 + b\). Using the definition of addition, \(a + 0 = a\), so both sides reduce to \(a + b\). Then we rewrite tactic `rw [add\_zero]` and `rfl` confirms it.
  
2. Inductive step: We assume that \(a + b + c = a + c + b\) holds for some \(c\), and we must prove \(a + b + \text{succ}(c) = a + \text{succ}(c) + b\). First we rewrite the addition of the successor using the `add\_succ` rule. Then by applying the inductive hypothesis and the commutativity of addition, we can transform both sides to eventually match, proving the equality.

\section*{Lessons from the Assignments}
\subsection*{Lesson from Week 2}
In week two we dived into the realtionship between mathematical proofs and lean proofs. We saw that the code in an of itself is a proof and in each step we are just translating into a language the lean will understand. Additionally, we spent time looking at how to prove things recursively. Looking at functions that call themselves as a solution. This requires a base case with a simple solution, like moving a single ring to the right tower, and the replace that simple solution with n so that we can continue to reduce down to our basecase and solve for any number of rings up to infinity. This is what we do in our unductive proofs, we have our base case, then our hypothesis for n + 1 and prove for all cases. 

\section{Week 3: Using LLMs for Literature Review}
\label{sec:week3}


In Week 3, I explored the topic of \textbf{Quantum Programming Languages} using an LLM to guide my investigation. I also began to code a computer in python without the help of any libraries.

\subsection*{Link to the Full Literature Review}
The full literature review, including the questions and answers from the LLM, can be found \href{https://github.com/cgillette25/CPSC-354/blob/main/week3/README.md}{here}.

\subsection*{Discord Post}

My discord name is Chaz Gillette and below is a copy of my Discord post summarizing the literature review:

\begin{quote}
\small
"What are some of the key differences between classical logic and constructive logic that we should be mindful of when working through the Lean tutorials?"
\end{quote}

\subsection*{Reviews I Voted For}
I voted for the following two reviews after reading them:

\begin{enumerate}
    \item \href{https://github.com/mdrivas/CPSC353-Assignment3/blob/main/README.md}{Review 1}
    \item \href{https://github.com/ATacoDev/LitReview354}{Review 2}
\end{enumerate}

\subsection*{Lessons Learned}
In week 3 I learned a lot about what makes programming for quantum computing different; mostly this is to do with the less binary nature of quantum computing compared to current computers. Outside of my report I learned how to break down order of operations when coding. Using functions to call other funcitons within parenthesis and begin to tackle the math equations like a real calculator would. 

\section{Week 4: Introduction to Parsing and Context-Free Grammars}
\label{sec:week4}

In Week 4, we delved into the concepts of parsing and context-free grammars, exploring how they are used to translate concrete syntax into abstract syntax. This is a crucial step in understanding how programming languages are processed and interpreted.

\subsection*{Key Concepts}

\begin{itemize}
    \item Concrete syntax: Represents a program as a string (e.g., "1 + 2 * 3")
    \item Abstract syntax: Represents a program as a tree structure
    \item Parsing: The process of transforming concrete syntax into abstract syntax
    \item Context-free grammar: A set of rules that define the structure of a language
\end{itemize}

\subsection*{Context-Free Grammar for Arithmetic Expressions}

We studied the following context-free grammar for arithmetic expressions:

\begin{verbatim}
Exp -> Exp '+' Exp1 
Exp1 -> Exp1 '*' Exp2              
Exp2 -> Integer            
Exp2 -> '(' Exp ')'  
Exp -> Exp1             
Exp1 -> Exp2
\end{verbatim}

\subsection*{Homework Solutions: Week 4}

For the homework, we were asked to parse various expressions using the given context-free grammar. Here are the step-by-step derivations for each problem:

\includegraphics[width=\textwidth, page=1]{/Users/cgillette/CPSC-354/Report/DerivationTrees.pdf}

\includegraphics[width=\textwidth, page=2]{/Users/cgillette/CPSC-354/Report/DerivationTrees.pdf}

\includegraphics[width=\textwidth, page=3]{/Users/cgillette/CPSC-354/Report/DerivationTrees.pdf}

\includegraphics[width=\textwidth, page=4]{/Users/cgillette/CPSC-354/Report/DerivationTrees.pdf}

\includegraphics[width=\textwidth, page=5]{/Users/cgillette/CPSC-354/Report/DerivationTrees.pdf}

The parsing process demonstrates how the grammar rules are applied to derive the final expression, showing the hierarchical structure of the arithmetic operation.

\subsection*{Lessons Learned}

In Week 4, I gained several important insights:

\begin{enumerate}
    \item The importance of context-free grammars in defining the structure of programming languages
    \item How parsing bridges the gap between concrete syntax (what we write) and abstract syntax (how the computer interprets it)
    \item The hierarchical nature of expressions and how this is captured in abstract syntax trees
    \item The role of parsing in compiler design and language processing
\end{enumerate}

This week's content has deepened my understanding of how programming languages are structured and interpreted, providing a foundation for more advanced topics in language design and implementation.

\section{Week 5: Logic Game Tutorial and Lecture Content}
\label{sec:week5}

In Week 5, we focused on the content covered in the lectures and completed the Lean logic game's tutorial world. Below are the solutions for Levels 1 through 8, along with a proof for Level 8 written in mathematical logic.

\subsection*{Solutions: Lean Logic Game Tutorial}
\hfill\break

\begin{enumerate}
    \item \textbf{Level 1:} \\
    \begin{lstlisting}[style=leanstyle]
example (P : Prop)(todo_list : P) : P := by
exact todo_list
    \end{lstlisting}

    \item \textbf{Level 2:} \\
    \begin{lstlisting}[style=leanstyle]
example (P S : Prop)(p: P)(s : S) : P ∧ S := by
exact ⟨p,s⟩
    \end{lstlisting}

    \item \textbf{Level 3:} \\
    \begin{lstlisting}[style=leanstyle]
example (A I O U : Prop)(a : A)(i : I)(o : O)(u : U) : (A ∧ I) ∧ O ∧ U := by
exact ⟨⟨a,i⟩,o,u⟩
    \end{lstlisting}

    \item \textbf{Level 4:} \\
    \begin{lstlisting}[style=leanstyle]
example (P S : Prop)(vm: P ∧ S) : P := by
exact vm.left
    \end{lstlisting}

    \item \textbf{Level 5:} \\
    \begin{lstlisting}[style=leanstyle]
example (P Q : Prop)(h: P ∧ Q) : Q := by
exact h.right
    \end{lstlisting}

    \item \textbf{Level 6:} \\
    \begin{lstlisting}[style=leanstyle]
example (A I O U : Prop)(h1 : A ∧ I)(h2 : O ∧ U) : A ∧ U := by
exact ⟨h1.left, h2.right⟩
    \end{lstlisting}

    \item \textbf{Level 7:} \\
    \begin{lstlisting}[style=leanstyle]
example (C L : Prop)(h: (L ∧ (((L ∧ C) ∧ L) ∧ L ∧ L ∧ L)) ∧ (L ∧ L) ∧ L) : C := by
exact h.left.right.left.left.right
    \end{lstlisting}

    \item \textbf{Level 8:} \\
    \begin{lstlisting}[style=leanstyle]
example (A C I O P S U : Prop)
(h: ((P ∧ S) ∧ A) ∧ ¬I ∧ (C ∧ ¬O) ∧ ¬U) : A ∧ C ∧ P ∧ S := by
exact ⟨h.left.right, h.right.right.left.left, h.left.left.left, h.left.left.right⟩
    \end{lstlisting}
\end{enumerate}



\subsection*{Level 8: Formal Proof in Mathematical Logic}

We want to show: If \(((P \land S) \land A) \land \neg I \land (C \land \neg O) \land \neg U\), then \(A \land C \land P \land S\).

\textbf{Proof:}

\begin{enumerate}
    \item \( (P \land S) \land A \) \hfill assumption
    \item \( \neg I \) \hfill assumption
    \item \( C \land \neg O \) \hfill assumption
    \item \( \neg U \) \hfill assumption
    \item \( A \) \hfill and\_right (1)
    \item \( C \) \hfill and\_left (3)
    \item \( P \) \hfill and\_left (1)
    \item \( S \) \hfill and\_right (1)
    \item \( A \land C \land P \land S \) \hfill and\_intro (5) (6) (7) (8)
\end{enumerate}

\subsection*{Discussion Question on Discord}

During this week's assignment, I asked the following question on Discord:

\begin{quote}
\small
"How scalable is Lean if applied to large-scale software verification projects?"
\end{quote}


\section*{Conclusion}
In week one, we reviewed our discrete math knowledge and began coding proofs. Week two we saw the relationship between mathematical proofs and lean code proofs, and then we began to solve problems recursively. The following week I took a dive into quantum computing languages in my literature review while also working on coding a calculator using a recursive approach to solve parenthesis. In week four, we explored parsing and context-free grammars, learning how to translate concrete syntax into abstract syntax, which is crucial for understanding how programming languages are processed. Week 5 used lean as a way of proving logic puzzles.

\end{document}